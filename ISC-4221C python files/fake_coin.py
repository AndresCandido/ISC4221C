# -*- coding: utf-8 -*-
"""fake_coin.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1S5-huO7sMI4Xkiv_1FTxRmsK0EFwFfym
"""

#==========================================================
# A simple python code for finding the fake coin
# under two conditions:
#   (1) the fake coin is lighter,
#   (2) the number of coins is 2^n
#==========================================================

import numpy as np

# define the coins
coins = np.array([[1, 1],   # [index, weight]
                 [2, 1],
                 [3, 0.8],  # fake coin
                 [4, 1],
                 [5, 1],
                 [6, 1],
                 [7, 1],
                 [8, 1]])


# split coins to two piles and extract the lighter pile
def check_pile(coins):
    num = len(coins)
    half = int(num/2)   # int(): change the type to integer.
    pile_left = coins[:half]
    pile_right = coins[half:]
    sum_left = np.sum(pile_left[:,1])
    sum_right = np.sum(pile_right[:,1])
    print ('left pile:\n', pile_left,'   sum: ',sum_left)
    print ('right pile:\n', pile_right,'  sum: ',sum_right)

    if sum_left/num != 0.5: #<------HERE IS THE MODIFICATION TO THE CODE, as long as the fake coin doesn't have the same weight as the real ones (and the real coins weight 1) the algorithm will find it.
        print('take left pile')
        return pile_left
    else:
        print('take right pile')
        return pile_right


############# main function starts #############
num_coin = len(coins)
pile = coins
iteration = 0

# loop until we have only one coin, which is the fake coin.
while num_coin>1:
    iteration = iteration + 1
    print('iteration: ',iteration)
    pile = check_pile(pile)
    num_coin = len(pile)
    print('\n')


print('index of the fake coin:',int(pile[0,0]),' weight:',pile[0,1])

